# Declarative Specification of Brick Hierarchy


Goal is to have a declarative specification that generates a consistent collection of tagsets

## Issues

Some issues with the hierarchy:

- really two things we want to communicate:
    1. what kind of system is a tagset *associated* with:
        - use "is Part Of"; maybe as part of the Brick definition?
    2. increasing levels of specificity/functionality:
        - this is really what classes are for. Valve -> Heating Valve, for example

- the class hierarchy is co-opting the structure to do the former. This is BAD!:
    - for example, subclasses of an AHU include a "preheat valve VFD"
- going to need to switch to some other kind of relationship for this:
    - maybe "usesEquipment"; this gets inherited DOWN the hierarchy
    - the "compiler" throws an exception/error if the target of "usesEquipment" is
      not defined elsewhere in Brick

## Subclasses

### Simple Hierarchy

```yaml
Point:
    subclasses:
        Alarm:
        Command:
        Meter:
        Sensor:
```

Class names are "complete". They are not composed or altered in anyway as we follow `subclasses` tags down the structure.


### Parameterizing with Tags

As the hierarchy gets deeper and more complex, we would like to use tags to describe what these classes are in a more structured and less error-prone manner.

```yaml
Point:
    subclasses:
        Sensor:
            types:
                CO2:
                    media: [Air]
                    types: [Outside, Return]
                    subtypes: [Differential, Level]
```

Here, the immediate subclass of `Sensor` is `CO2`; following tag composition rules, the generated class name becomes `CO2 Sensor`. The subclasses of `CO2 Sensor` are those formed by the cross product of `media` and `types`. Per tag composition rules, `media` gets placed closest to the parent class name.

For each of these, the `subtypes` generates a new set of subclasses.

The resulting set of classes are below, with nesting indicating subclassing:
- `Point`
    - `Sensor`
        - `CO2 Sensor`
            - `Outside Air CO2 Sensor`
                - `Differential Outside Air CO2 Sensor`
                - `Level Outside Air CO2 Sensor`
            - `Return Air CO2 Sensor`
                - `Differential Return Air CO2 Sensor`
                - `Level Return Air CO2 Sensor`

If we want to specify "subtypes" for just one of the tags, we can use the normal "types" structure:

```yaml
Point:
    subclasses:
        Sensor:
            types:
                CO2:
                    media: [Air]
                    types:
                        - Outside
                            types: [Differential, Level]
                        - Return
```

which would generate


- `Point`
    - `Sensor`
        - `CO2 Sensor`
            - `Outside Air CO2 Sensor`
                - `Differential Outside Air CO2 Sensor`
                - `Level Outside Air CO2 Sensor`
            - `Return Air CO2 Sensor`

### Combining Tags with Subclasses

Classes generated by tags (via `media`, `types`) are in addition to any explicitly designated subclasses.

```yaml
Point:
    subclasses:
        Sensor:
            types:
                CO2:
                    media: [Air]
                    types: [Outside, Return]
                    subclasses:
                        CO2 Differential Sensor
```

generates

- `Point`
    - `Sensor`
        - `CO2 Sensor`
            - `Outside Air CO2 Sensor`
            - `Return Air CO2 Sensor`
            - `Differential CO2 Sensor`


### Synonyms

Tags and classes can have synonyms.

For classes, this can be explicit:

```yaml
Domestic Hot Water Supply Temperature Sensor:
    synonyms: Domestic Hot Water Discharge Temperature Sensor
```

For tags, this can be done declaratively. The generated class names will be duplicated with all of the synonyms replaced.

```yaml
Zone Temperature Sensor:
    types:
        - Average
        - Highest:
            synonyms: Warmest
        - Lowest:
            synonyms: Coldest
```

generates

- `Zone Temperature Sensor`
    - `Average Zone Temperature Sensor`
    - `Highest Zone Temperature Sensor`
    - `Warmest Zone Temperature Sensor` (equivalent to above)
    - `Lowest Zone Temperature Sensor`
    - `Coldest Zone Temperature Sensor` (equivalent to above)

The equivalances will be captured in the generated ontology.

#### Note: Overriding Tag Composition Rules

Above, "Level Outside Air CO2 Sensor" makes slightly less sense than "Outside Air CO2 Level Sensor".
Maybe we can use a template to allow overriding the normal tag composition rules

```yaml
Point:
    subclasses:
        Sensor:
            types:
                CO2:
                    media: [Air]
                    types: [Outside, Return]
                    template: $types $media CO2 $subtypes Sensor
                    subtypes: [Differential, Level]
```

